from i2clibraries import i2c_adxl345
from time import *

from datetime import datetime
import os

# Declare ADXL345 class from adxl345 library
myADXL = i2c_adxl345.i2c_adxl345(1)

# Interval controls how often we retrieve axes (seconds)
interval = 0.1

# Declare counters and counterError
counter = 0
counterFile = 0
maxCounterFile = 90000
counterError = 0
maxCounterToWrite = 36000
displayLoop = True
display = True

fileNumber = 1

# Declare list to store data from accelerometer
dataList = []

# Declare calibration values (x,y,z)
x_fix = 0
y_fix = 0
z_fix = 0
calibrationValues = [x_fix, y_fix, z_fix]

# Declare threshold values (for checking significance)
# Value in g
x_threshold = 0.4
y_threshold = 0.4
z_threshold = 1.4
significanceThresholds = [x_threshold, y_threshold, z_threshold]

def strConvertAxes (x,y,z):
	return (str(x),str(y),str(z))

def printAxes (x,y,z):
	(x,y,z) = strConvertAxes(x,y,z)

	print("\n\nADXL (g)")
	print("X: " + x)
	print("Y: " + y)
	print("Z: " + z)	

def trackCounter(counter, counterError, counterFile, display):
	counter += 1
	counterFile += 1

	if display:
		print("COUNT: " + str(counter))
		print("LOST COUNTS: " + str(counterError))
	else:
		if counter % 2 == 0:
			print("ADXL Running")
		else:
			print("ADXL Running!")
	
	return (counter, counterFile)
	
def addToList(dataList, x, y, z, time):
	#(x,y,z) = strConvertAxes(x,y,z)
	axesPacket = [x,y,z,time]
	dataList.append(axesPacket)
	return dataList

def getXYZtFromPacket(packet):
	x = packet[0]
	y = packet[1]
	z = packet[2]
	time = packet[3]
	return (x, y, z, time)

# before writing to disk, check entire list if anything significant happened. Otherwise, delete.

def checkListForSignificance(dataList):
	
	x_threshold = significanceThresholds[0]
	y_threshold = significanceThresholds[1]
	z_threshold = significanceThresholds[2]
	
	for packet in dataList:
		(x, y, z, time) = getXYZtFromPacket(packet)
		if x > x_threshold or x < (x_threshold * -1):
			return True
		if y > y_threshold or y < (y_threshold * -1):
			return True
		if z > z_threshold or z < (z_threshold * -1):
			return True
	return False

def writeToDisk(dataList, interval, check, fileNumber):
	
	# Format file numbering for 01, 02 ... 09 etc
	if fileNumber < 10:
		fileNumberWrite = '0' + str(fileNumber)
	else:
		fileNumberWrite = fileNumber
	
	# If prompted to check and list has NO significant values, record that no data was significant
	if check and checkListForSignificance(dataList) == False:
		mainDataFile = open('ADXLData/ADXLdata_Insignificant', 'a')
		mainDataFile.write("No significant data @ time: " + str(datetime.now()) + "\n")
		mainDataFile.close()
		return
	
	mainDataFile = open('ADXLData/ADXLdata_' + str(fileNumberWrite), 'w')
	fileNumber += 1
	mainDataFile.write("ADXL345 Data File\nSample Rate: " + str(interval) + "\nSamples: " + str(len(dataList)/5) + "\n")	
	for packet in dataList:
		(x, y, z, time) = getXYZtFromPacket(packet)
		(x,y,z) = strConvertAxes(x,y,z)
		mainDataFile.write(x + " " + y + " " + z + " " + str(time) + "\n")
		
	mainDataFile.close()
	
			

def getCalibrationOffsets ():
	# Collect data for a certain amount of time to get averages (for subtraction)

	counterCalibrate = 0
	counterCalibrateMax = 100
	calibrateList = []
	calibrateValues = []
	calibrateLoop = True
	
	x_average = 0
	y_average = 0
	z_average = 0
	
	while counterCalibrate <= counterCalibrateMax:
		counterCalibrate += 1
		(accel_x, accel_y, accel_z) = myADXL.getAxes()
		calibrateValues = [accel_x, accel_y, accel_z]
		calibrateList.append(calibrateValues)
		
	for	dataValues in calibrateList:
		x_average += dataValues[0]
		y_average += dataValues[1]
		z_average += dataValues[2]
	
	x_fix = (x_average / len(calibrateList))*-1
	y_fix = (y_average / len(calibrateList))*-1
	z_fix = ((z_average / len(calibrateList))*-1)+1
	calibrationValues = [x_fix, y_fix, z_fix]
	
	return calibrationValues
	
	
def calibrateAxesValues(x, y, z, calibrationValues):
	# calibrationValues returns (x, y, z) fix values
	x += calibrationValues[0]
	y += calibrationValues[1]
	z += calibrationValues[2]
	return (x, y, z)
		
		
def mainDisplayADXL (interval, write, display):
	# Interval is in seconds, and controls how often we read and print from ADXL
	# Use "try/except" to prevent IOError from interrupting display loop
	# We will increment an error counter to track loss
	
	# these variables are called global TEMPORARILY
	global counter
	global counterFile
	global displayLoop
	global dataList
	global significanceFilter
	global fileNumber
	global counterError
	global calibrationValues
	
	try:
		os.system("clear")
		(counter, counterFile) = trackCounter(counter, counterError, counterFile, display)
		
		(accel_x, accel_y, accel_z) = myADXL.getAxes()
		(accel_x, accel_y, accel_z) = calibrateAxesValues(accel_x, accel_y, accel_z, calibrationValues)
		
		if display:
			printAxes(accel_x, accel_y, accel_z)
			print(str(datetime.now()))
			print("\nRetrieving every " + str(interval) + " seconds")
			
		if write:
			dataList = addToList(dataList, accel_x, accel_y, accel_z, str(datetime.now()))
			if counterFile >= maxCounterFile:
				writeToDisk(dataList, interval, significanceFilter, fileNumber)
				dataList = []
				counterFile = 0
			if counter >= maxCounterToWrite:
				displayLoop = False
			
	except IOError:
		counterError += 1

	sleep(interval)
	



	
###################################

# Get current values from resting ADXL345, average, and use to "calibrate"
calibrationValues = getCalibrationOffsets()


interval = float(input("\nEnter interval: "))
maxCounterToWrite = (float(input("\nHow long for: (m) "))*60)/interval
maxCounterFile = (float(input("\nSave file every: (m) "))*60)/interval

significanceFilter = input("\nSave only significant data? (0,1): ")
if significanceFilter == 0:
	significanceFilter = False
else:
	significanceFilter = True

print ("Interval: " + str(interval))
print ("Duration: " + str(maxCounterToWrite))
print ("Save Intervals; " + str(maxCounterFile))


display = float(input("\nDisplay? (0, 1): "))
if display == 0:
	display = False
else:
	display = True

## MAIN LOOP 

myADXL.setScale(4)

while displayLoop:
	mainDisplayADXL(interval, True, display)
